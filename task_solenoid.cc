//======================================================================================/** \file  task_solenoid.cc *  Task which controls the solenoid to keep the camera awake and take pictures when *  flagged * *  Revisions: *    \li  05-31-08  Created file * *  License: *    This file released under the Lesser GNU Public License. The program is intended *    for educational use only, but its use is not restricted thereto.  *///======================================================================================#include <stdlib.h>#include <avr/io.h>#include "stl_debug.h"#include "rs232.h"#include "stl_us_timer.h"#include "stl_task.h"#include "task_solenoid.h"const char GOING_DUTY_CYCLE = 100;          // Duty cycle for motor when it's goingconst char STOP_RIGHT = 0;                  // State: Stopped, was moving to the rightconst char GO_RIGHT = 1;                    // State: Going to the rightconst char STOP_LEFT = 2;                   // State: Stopped, was moving to the leftconst char GO_LEFT = 3;                     // State: Going to the leftconst unsigned int TURN_CCW_CW = 330;       // Where to turn motor around at each endconst unsigned int TURN_CW_CCW = 530;       // //-------------------------------------------------------------------------------------/** This constructor creates a solenoid task object. The motor object needs pointers to *  an solenoid controller in order to do its thing.  *  @param t_stamp A timestamp which contains the time between runs of this task *  @param p_mot   A pointer to a motor controller object *  @param p_a2d   A pointer to an analog to digital converter object *  @param p_ser   A pointer to a serial port for sending messages if required */task_solenoid::task_solenoid (time_stamp* t_stamp, motor405a* p_mot, avr_adc* p_a2d,     base_text_serial* p_ser)    : stl_task (*t_stamp, p_ser)    {    p_motor = p_mot;                        // Save pointers to other objects    p_adc = p_a2d;    p_serial = p_ser;    // Set the motor's power (or brake) duty cycle    p_motor->set_duty_cycle (GOING_DUTY_CYCLE);    // Say hello    p_serial->puts ("Motor task constructor\r\n");    }//-------------------------------------------------------------------------------------/** This is the function which runs when it is called by the task scheduler. It causes *  the motor to move back and forth, having several states to cause such motion.  *  @param state The state of the task when this run method begins running *  @return The state to which the task will transition, or STL_NO_TRANSITION if no *      transition is called for at this time */char task_solenoid::run (char state)    {    switch (state)        {        // In State 0, the motor should stop; when it starts up again, we want it        // to be going to the right        case (STOP_RIGHT):            p_motor->set_duty_cycle (0);            if (going)                return (GO_RIGHT);            break;        // In State 1, the motor goes to the right        case (GO_RIGHT):            p_motor->clockwise ();            p_motor->set_duty_cycle (GOING_DUTY_CYCLE);            if (!going)                return (STOP_RIGHT);            // If the A/D reading is at the end, turn around            if (p_adc->read_once (0) > TURN_CW_CCW)                return (GO_LEFT);            break;        // State 2 is for stopping the motor while going left        case (STOP_LEFT):            p_motor->set_duty_cycle (0);            if (going)                return (GO_LEFT);            break;        // In State 3, the motor moves to the left        case (GO_LEFT):            p_motor->counterclockwise ();            p_motor->set_duty_cycle (GOING_DUTY_CYCLE);            if (!going)                return (STOP_LEFT);            // If the A/D reading is at the end, turn around            if (p_adc->read_once (0) < TURN_CCW_CW)                return (GO_RIGHT);            break;        // If the state isn't a known state, call Houston; we have a problem        default:            STL_DEBUG_PUTS ("WARNING: Motor control task in state ");            STL_DEBUG_WRITE (state);            STL_DEBUG_PUTS ("\r\n");            return (STOP_RIGHT);        };    // If we get here, no transition is called for    return (STL_NO_TRANSITION);    }