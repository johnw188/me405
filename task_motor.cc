//======================================================================================/** \file  task_motor.cc *  Task which controls the motor to position the camera/sensor * *  Revisions: *    \li  05-31-08  Created file * *  License: *    This file released under the Lesser GNU Public License. The program is intended *    for educational use only, but its use is not restricted thereto.  *///======================================================================================#include "task_motor.h"//-------------------------------------------------------------------------------------/** This constructor creates a motor task object. The motor object needs pointers to *  a solenoid controller in order to do its thing.  *  @param t_stamp A timestamp which contains the time between runs of this task *  @param p_mot   A pointer to a solenoid controller object *  @param p_ser   A pointer to a serial port for sending messages if required */task_motor::task_motor (time_stamp* t_stamp, base_text_serial* p_ser, controls* p_controls) : stl_task (*t_stamp, p_ser){	ptr_serial = p_ser;	ptr_controls = p_controls;	// Say hello	ptr_serial->puts ("Motor task constructor\r\n");	target_position = 0;	previous_position = 0;	current_position = 0;	ptr_controls->start_geared_position_control(0, 8, 0);}//-------------------------------------------------------------------------------------/** This is the function which runs when it is called by the task scheduler. It causes *  the solenoid to go up and down, having several states to cause such motion.  *  @param state The state of the task when this run method begins running *  @return The state to which the task will transition, or STL_NO_TRANSITION if no *      transition is called for at this time */char task_motor::run (char state){ 	//ptr_serial->puts("motor should update controls now\n\r");	ptr_controls->update_geared_position_control();		previous_position = current_position;	current_position = get_current_position();	return (STL_NO_TRANSITION);}int task_motor::get_target_position(){	return target_position;}int task_motor::get_current_position(){	return ptr_controls->get_motor_gear_position();}void task_motor::increment_position(int increment){	target_position += increment;	ptr_controls->change_gear_position(target_position);}bool task_motor::position_stable(void){	if(previous_position == current_position && current_position > (target_position - 2) && current_position < (target_position + 2))		return true;	return false;}	