//======================================================================================/** \file  task_sensor.cc *  Task which controls the acquisition of sensor readings from the sharp IR rangefinder * *  Revisions: *    \li  05-31-08  Created file * *  License: *    This file released under the Lesser GNU Public License. The program is intended *    for educational use only, but its use is not restricted thereto.  *///======================================================================================#include "task_sensor.h"// S T A T E S:const char WAITING = 0;                  		// Is waiting for change of stateconst char TAKE_READING = 1;                    	// Is taking a reading from ADC-Portconst char TAKE_INITIAL_READING = 2;			// Writes initial values to array//-------------------------------------------------------------------------------------/** This constructor creates a motor task object. The motor object needs pointers to *  a solenoid controller in order to do its thing.  *  @param t_stamp A timestamp which contains the time between runs of this task *  @param p_mot   A pointer to a solenoid controller object *  @param p_ser   A pointer to a serial port for sending messages if required */task_sensor::task_sensor (time_stamp* t_stamp, sharp_sensor_driver* p_sharp_sensor_driver, 				task_motor* p_task_motor, base_text_serial* p_ser)    : stl_task (*t_stamp, p_ser)    {	ptr_sharp_sensor_driver = p_sharp_sensor_driver;                        // Save pointers to other objects	ptr_serial = p_ser;	ptr_task_motor = p_task_motor;	take_reading_flag = false;	reading_taken_flag = true;	change_detected = false;    // Say hello    ptr_serial->puts ("Sensor task constructor\r\n");    }//-------------------------------------------------------------------------------------/** This is the function which runs when it is called by the task scheduler. It causes *  the solenoid to go up and down, having several states to cause such motion.  *  @param state The state of the task when this run method begins running *  @return The state to which the task will transition, or STL_NO_TRANSITION if no *      transition is called for at this time */char task_sensor::run (char state)    {    switch (state)        {        // In State 0, the motor should stop; when it starts up again, we want it        // to be going to the right	case (WAITING):        	if(take_reading_flag){			take_reading_flag = false;			reading_taken_flag = false;			return(TAKE_READING);		}		if(take_initial_reading_flag){			take_initial_reading_flag = false;			return(TAKE_INITIAL_READING);		}            break;        // In State 1, the sensor reads a value and compars it to the initialization        case (TAKE_READING):		ptr_sharp_sensor_driver->get_distance();		if (ptr_sharp_sensor_driver->sth_changed(ptr_task_motor->get_position()))			change_detected = true;		reading_taken_flag = true;		return(WAITING);            break;        case (TAKE_INITIAL_READING):		ptr_sharp_sensor_driver->init_sensor_values(ptr_task_motor->get_position());		reading_taken_flag = true;		return(WAITING);            break;        // If the state isn't a known state, call Houston; we have a problem        default:		STL_DEBUG_PUTS ("WARNING: Sensor control task in state ");		STL_DEBUG_WRITE (state);		STL_DEBUG_PUTS ("\r\n");		return(WAITING);        };    // If we get here, no transition is called for    return (STL_NO_TRANSITION);    }/** This method is called to tell the sensor to take a reading */bool task_sensor::change_detected(void){	return change_detected;}void task_sensor::take_reading (void)    {    ptr_serial->puts ("Take reading\r\n");    take_reading_flag = true;    }bool task_sensor::reading_taken(void){	if(reading_taken_flag){		reading_taken_flag = false;		return true;		}	else{		return false;	}}bool task_sensor::check_reading_taken(void){	return reading_taken_flag;}/** This method is called to tell the sensor to take a the initial reading */void task_sensor::init_sensor_values (void){    ptr_serial->puts ("Take initial reading\r\n");    take_initial_reading_flag = true;}